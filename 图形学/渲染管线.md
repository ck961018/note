# 渲染管线笔记

## 1.应用程序阶段
> &emsp;&emsp;应用程序阶段的任务是准备传入GPU的数据，该阶段运行在CPU上，由开发人员完全掌控。在这个阶段决定传入GPU什么数据（如模型位置、相机位置、光源位置等）、这些数据的渲染状态（如纹理、材质等）以及某些时候对这些数据的处理（如剔除视锥外的模型）。

## 2.几何阶段
> + #### 传入数据及Draw Call
> &emsp;&emsp;CPU将应用阶段准备的数据传入显存中，并对GPU发布渲染命令。
> + #### 顶点着色器
> &emsp;&emsp;顶点着色器主要是进行MVP变换，有时候也会为后面的着色操作准备一些信息，如每个顶点的光照、阴影等等。也可以进行着色计算，比如平面着色和高洛德着色。
> + #### 曲面细分着色器
> &emsp;&emsp;曲面细分着色器用来细分图元以获取更多的细节。
> + #### 几何着色器
> &emsp;&emsp;几何着色器与曲面细分着色器一样是可选的。它将输入的图元变换为新的图元，主要亮点在于可以创建和销毁顶点。
> + #### 裁剪
> &emsp;&emsp;之前的MVP变换将顶点变换到NDC空间中，裁剪阶段就是将不在范围内的顶点剔除。（保护带裁剪：只裁剪视口内和保护带外均有交集的三角形）
> + #### 屏幕映射
> &emsp;&emsp;将NDC空间中的坐标映射到窗口坐标系上。

## 3.光栅化阶段
> + #### 三角形设置（图元装配）
> &emsp;&emsp;三角形设置阶段的主要作用是计算出一些在三角形遍历阶段会被多次用到的数据以减少运算量。比如三条边的方程、顶点坐标等等。
> + #### 三角形遍历
> &emsp;&emsp;检验屏幕上的像素是否被某个三角形覆盖，覆盖的区域生成片元，一般有三种方案：标准光栅化、内保守光栅化、外保守光栅化。除此之外，也会对像素的属性值进行插值。

## 4.像素处理阶段
> + #### 像素着色
> &emsp;&emsp;根据之前的信息决定屏幕像素的颜色，这一阶段是完全可编程的。各种复杂的着色模型和光照计算都是在这一阶段完成。
> + #### 测试合并
> &emsp;&emsp;进行各种测试和混合操作，如裁剪测试、深度测试、模板测试、透明测试等。经过测试合并阶段存到帧缓存中的像素值才是最终呈现在屏幕上的图像。

## 其他知识点
> + ####  深度测试
> &emsp;&emsp;每个像素保存一个深度值，每个片段用自己的深度值和缓冲的深度值进行测试，通过测试则保留并更新深度值，不通过则丢弃。简单来说就是根据深度决定是否渲染。
> &emsp;&emsp;深度测试会采用非线性的深度值，给近处的物体较高的精度，远处的物体较低的精度。
> &emsp;&emsp;当两个三角形非常接近，深度缓冲的精度不足以判断先后时，会产生深度冲突（z-fighting）。解决方法有两个：1、更高的精度，大部分深度缓冲是24位，但现在显卡都支持32位了；2、给物体间设置一个非常小的间隔。
> + ####  模板测试
> &emsp;&emsp;每个像素保存一个八位模板值，可以自己设置什么情况下通过测试，什么时候更新模板值，每个片段只有通过测试才能保留。可以想象成将一个模板放在屏幕上，之后模板中的空隙可以渲染出来。简单来说就是根据物体的位置决定是否渲染。
> + ####  Alpha测试
> &emsp;&emsp;跟深度测试一样保存一个透明值，根据透明值决定是否渲染。
> + ####  裁剪测试
> &emsp;&emsp;开一个裁剪框，只有裁剪框内的片段才会被渲染出来。
> + ####  测试顺序
> &emsp;&emsp;裁剪测试 -> Alpha测试 -> 模板测试 -> 深度测试
> + ####  Early-Z
> &emsp;&emsp;将深度测试放在光栅化之后、像素处理之前，可以减少进入着色阶段的片段，提升性能。但Early-Z会导致透明测试的冲突，解决方法有Z-Prepass、双Pass等。同时，片段着色阶段修改深度值的话也不能进行Early-Z。
> + ####  Z-Prepass
> &emsp;&emsp;先渲染一次深度，再关闭深度写入，进行一次渲染。可以渲染透明物体并避免不可见物体的着色。缺点是要进行两次顶点计算。